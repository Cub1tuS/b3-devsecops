# Part 1 : DevOps init

## Index

- [Part 1 : DevOps init](#part-1--devops-init)
  - [Index](#index)
  - [1. Create code repo](#1-create-code-repo)
  - [2. Grab the code](#2-grab-the-code)
  - [3. Gitlab Runner](#3-gitlab-runner)
    - [A. Intro](#a-intro)
    - [B. Install and conf](#b-install-and-conf)
  - [4. First pipeline](#4-first-pipeline)
  - [Go next](#go-next)

## 1. Create code repo

‚ûú **Go sur [Gitlab](https://gitlab.com)**

- cr√©er un compte et connectez-vous si c'est pas d√©j√† fait
- cr√©er un nouveau d√©p√¥t git vide et **public**
- **appelez le d√©p√¥t `broken_webapp`**

‚ûú **Get the repo**

- clonez le d√©p√¥t sur votre machine, votre PC, votre OS (pas une VM ou koa)
- utilisez la ligne de commande `git` depuis votre PC
- poussez un ptit `README.md` tout pourri de votre choix (`add`, `commit`, `push`)

> V√©rifiez que le fichier `README.md` est visible sur la WebUI avant de continuer.

üåû **Balancez l'URL de ce d√©p√¥t `broken_webapp` dans le compte-rendu Markdown**

## 2. Grab the code

üåû **R√©cup√©rez le code**

- uniquement avec des commandes shell ~bande de noobs~ que vous me mettez dans le compte-rendu
- le code est dans ce d√©p√¥t git, √† c√¥t√© des fichiers markdown pour le TP, dans le sous-dossier [**`app/` ici**]

üåû **Lancez le code, histoire de voir ce qu'il fait**

- un simple `docker compose up` depuis le dossier qui contient le `docker-compose.yml` devrait suffire
- prouvez avec un `curl` que vous pouvez visiter l'application

üåû **Connectez-vous sur la WebUI**

- des users ont √©t√© cr√©√©s en base de donn√©es au moment de votre `docker compose up`
- cherchez o√π et comment ils ont √©t√© cr√©√©s (c'est dans le dossier `app/` quelque part hein) automatiquement, pour apprendre un couple de user/password qui existe :)
- prouvez avec un `curl` que vous arrivez √† vous connecter

> Si vous vous connectez en navigateur d'abord (recommand√©), vous pouvez r√©cup√©rer la requ√™te qu'a fait votre navigateur sous forme de requ√™te `curl`, c'est id√©al pour rejouer une requ√™te de connexion comme celle-ci. Demandez √† Google ou Gepetto, √ßa se fait depuis la console du navigateur, onglet "R√©seau".

üåû **`add`, `commit`, `push`**

- poussez tout le contenu de mon dossier `app/` dans le d√©p√¥t `broken_webapp` que vous avez cr√©√©
- u know what to do, j'veux les commandes dans le compte-rendu
  - allez on est sur un TP avec `git` au coeur de toutes les op√©rations, essayez de pas faire des messages de commits trop nazes :d
- vous devez conserver l'architecture du dossier `app/` dans votre d√©p√¥t
  - fichier `Dockerfile` √† la racine
  - fichier `docker-compose.yml` √† la racine
  - dossier `src/` qui contient le code

‚ûú **A la racine du d√©p√¥t, vous devriez donc avoir :**

- votre `README.md`
- fichier `Dockerfile`
- fichier `docker-compose.yml`
- un dossier `src` (qui contient tout le code)
- kom sa koa :

```bash
‚ùØ ls
docker-compose.yml  Dockerfile  README.md  src
```

## 3. Gitlab Runner

### A. Intro

Quand on fait de la CI/CD avec GitLab, on a besoin d'utiliser des *Runner*. Un *Runner* est une machine qui va ex√©cuter les tests automatis√©s.

Concr√®tement :

- on fait un `git push` pour envoyer du code sur GitLab
- √† la r√©ception du `push`, Gitlab va contacter un *Runner* associ√© au d√©p√¥t
- il va demander au *Runner* d'ex√©cuter les tests list√©s dans le fichier `.gitlab-ci.yml`

Avant de pouvoir lancer nos premiers tests automatis√©s, il faut donc qu'on installe et configure un *Runner GitLab*.

On va faire √ßa sur une VM Rocky locale, vous pouvez faire chauffer VirtualBox.

![Gitlab CI/CD](./img/logo_gitlab_cicd.png

### B. Install and conf

‚ûú **Allumez une VM Rocky**

- elle doit avoir un acc√®s internet, et vous l'administrez en SSH

üåû **Installer Docker**

- [suivez la doc officielle](https://docs.docker.com/engine/install/centos/) pour installer Docker SVP :'(
- `start` et `enable` le service `docker.service`

> En effet, le *Runner Gitlab* va utiliser Docker pour lancer les tests ! Pour lancer un test, le *Runner* r√©cup√®re le code du d√©p√¥t Git dans un conteneur √©ph√©m√®re, il effectue les tests, et le conteneur est d√©truit √† la fin des tests. La conteneurisation trouve ici un cas d'utilisation de fou : c'est juste trop pratique de pouvoir lancer des ptits conteneurs √† la vol√©e, pour effectuer des tests dedans, et d√©truire apr√®s :)

üåû **Installer un Runner Gitlab**

- [suivez la doc officielle](https://docs.gitlab.com/runner/install/)
- je vous recommande de l'installer directement sur la machine h√¥te (pas de l'installer avec Docker)
- `start` et `enable` le service `gitlab-runner.service`

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è **Avant de continuer, assurez-vous que vous voyez votre *Runner* dans la WebUI de GitLab**

- depuis la page principale de votre repo `broken_webapp`
- dans le menu lat√©ral, allez dans la section `Settings > CI/CD > Runners`
- vous devriez voir votre *Runner* qui s'est enregistr√©

## 4. First pipeline

Allez, notre premi√®re *pipeline*. C'est un mot g√©n√©rique pour d√©signer un truc √† ex√©cuter automatiquement dans un d√©p√¥t git.

On va donc cr√©er notre premi√®re *pipeline* avec GitLab : **en cr√©ant un fichier `gitlab-ci.yml` √† la racine du d√©p√¥t git.**

Une *pipeline* Gitlab est compos√©e de plusieurs *stages*. Chaque *stage* consiste en une s√©rie de *job*. Chaque *job* est une commande ou une suite de commande √† ex√©cuter dans un environnement pr√©cis.

> Vous allez voir, √ßa va prendre du sens au fur et √† mesure du TP, on va poncer ces concepts !

‚ûú **Ajoutez un fichier `gitlab-ci.yml` √† la racine de votre d√©p√¥t `broken_webapp`**

- il doit contenir √ßa :

```yml
image: debian:latest

stages:
  - meow

meow-job:
  stage: meow
  before_script:
    - apt-get update -qq
    - apt-get install -y cowsay
  script:
    - /usr/games/cowsay "Meoooow"
```

üåû **`add`, `commit`, `push`**

- pour ajouter le fichier `gitlab-ci.yml` au d√©p√¥t
- un message de commit psa tout pourri encore svp :ddd

![Break the build](./img/dont_always_commit.jpg)

‚ûú **RDV sur la WebUI de GitLab**

- allez sur la page principale de votre repo `broken_webapp`, et v√©rifiez que vous voyez bien le fichier `.gitlab-ci.yml`
- toujours depuis la page de votre repo `broken_webapp`, depuis le menu lat√©ral, allez dans la section `Build`
- vous devriez voir votre *job* en cours d'ex√©cution, vous pouvez avoir l'output du test

> Le *job* a √©t√© ex√©cut√© sur votre machine *Gitlab Runner*, qui a lanc√© un conteneur √©ph√©m√®re (avec Docker) pour ex√©cuter le code demand√©. Vous pouvez consulter l'output console du *job* depuis la WebUI, et vous pourrez voir que la premi√®re √©tape avant d'ex√©cuter notre *job* c'est de cloner le d√©p√¥t git √† l'int√©rieur du conteneur √©ph√©m√®re. Beh ui, comme √ßa il peut faire des tests dessus !

‚ö†Ô∏è‚ö†Ô∏è‚ö†Ô∏è **Ne continuez pas tant que vous n'avez pas vu votre *job* s'ex√©cuter et vous devriez pouvoir voir l'output du test. Donc tu continues pas tant que t'as pas vu une vache miauler**

```
 _________
< Meoooow >
 ---------
        \   ^__^
         \  (oo)\_______
            (__)\       )\/\
                ||----w |
                ||     ||
```

## Go next

üëâ [**Gogogo partie 2 : Test then Build**](./part2.md)
